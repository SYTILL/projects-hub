<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>p5.js with Matter.js</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
    <style>
        .container {
            height: 100vh;
            display: flex;
            flex-direction: row;
            justify-content: space-evenly;
        }

        #canv {
            position: relative;
            border: 1px solid black;
            margin: 40px;
            width: 800px;
            height: 600px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #overlay-box {
            position: absolute;
            width: 80px;
            height: 80px;
            background-color: blue;
            opacity: 0.5;
            border-radius: 10px;
            /* Rounded corners */
        }

        #bottom {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 20px;
            background-color: red;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="canv"></div>
        <div id="bottom"></div>
    </div>
    <script>
        const canvasHeight = 600;

        let engine = Matter.Engine.create({ gravity: { x: 0, y: 0 } });
        let world = engine.world;

        let render = Matter.Render.create({
            element: document.getElementById('canv'),
            engine: engine,
        });

        let ground = Matter.Bodies.rectangle(400, canvasHeight, 810, 60, { isStatic: true });


        
        const boxInfo = {
            h: 160,
            w: 210,
            gap: 20,
            num1: 5,
            num2: 6,
        };
        function createBoxes(info){
            let boxes = [];
            const col1posX = 220;
            const col2posX = col1posX+info.gap+info.w;
            
            for (let i=0;i<info.num1;i++){
                let box = Matter.Bodies.rectangle(
                    col1posX, 
                    (info.h+info.gap)*i, 
                    info.w, 
                    info.h, 
                    { chamfer: { radius: 25 }, dir: "UP" }
                );
                boxes.push(box)
            }
            
            for (let i=0;i<info.num2;i++){
                let box = Matter.Bodies.rectangle(
                    col2posX, 
                    (info.h+info.gap)*i, 
                    info.w, 
                    info.h, 
                    { chamfer: { radius: 25 }, dir: "DOWN" }
                );
                boxes.push(box)
            }

            return boxes;
        }
        var objectsBoxes = createBoxes(boxInfo);

        Matter.World.add(world, objectsBoxes);
        Matter.Engine.run(engine);
        Matter.Render.run(render);

        // Create bottom to disable gravity
        let bottom = document.getElementById('bottom');
        var gravityOn = false;
        var jumpOn = false;
        bottom.addEventListener('click', () => {
            if (gravityOn == false) {
                engine.gravity.y = 1;
                bottom.style.backgroundColor = 'green';
                jumpOn = true;
                gravityOn = true;
                Matter.World.add(world, ground);
            }
        });


        function controlBoxMovement() {
            for (let box of objectsBoxes) {
                let position = box.position;
                let angle = box.angle;

                if (jumpOn) {
                    let randVelo = Math.random() * 4 - 2;
                    let randAng = (Math.random() * 0.02) - 0.01;
                    Matter.Body.setVelocity(box, { x: box.velocity.x+randVelo, y: box.velocity.y-2+randVelo });
                    Matter.Body.setAngularVelocity(box, randAng);
                }
                
                if (box.dir)

                if (!gravityOn) {
                    position.y -= 0.01;
                }
                if (position.y < 0) {
                    Matter.Body.setPosition(box, { x: position.x, y: (boxInfo.h+boxInfo.gap)*boxInfo.num1 });
                }

                //Matter.Body.setPosition(box, { x: position.x, y: position.y });
            }
            if (jumpOn){
                jumpOn = false;
            }
        }

        function updateOverlay() {
            controlBoxMovement();

            requestAnimationFrame(updateOverlay);
        }

        updateOverlay();


    </script>
</body>

</html>