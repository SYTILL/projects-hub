<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>p5.js with Matter.js</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
    <style>
        .container {
            height: 100vh;
            display: flex;
            flex-direction: row;
            justify-content: space-evenly;
        }

        #canv {
            position: relative;
            border: 1px solid black;
            margin: 40px;
            width: 800px;
            height: 600px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #overlay-box {
            position: absolute;
            width: 80px;
            height: 80px;
            background-color: blue;
            opacity: 0.5;
            border-radius: 10px;
            /* Rounded corners */
        }

        #bottom {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 20px;
            background-color: red;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="canv"></div>
        <div id="bottom"></div>
    </div>
    <script>
        const canvasHeight = 600;

        let engine = Matter.Engine.create({ gravity: { x: 0, y: -0.5 } });
        let world = engine.world;

        let render = Matter.Render.create({
            element: document.getElementById('canv'),
            engine: engine,
        });

        let ground = Matter.Bodies.rectangle(400, canvasHeight, 810, 60, { isStatic: true });

        // Create box with rounded corners
        let boxA = Matter.Bodies.rectangle(400, 200, 80, 80, { chamfer: { radius: 10 } });
        let boxB = Matter.Bodies.rectangle(450, 50, 80, 80);

        var objectsBoxes = [boxA, boxB];

        Matter.World.add(world, objectsBoxes + [ground]);
        Matter.Engine.run(engine);
        Matter.Render.run(render);

        // Create bottom to disable gravity
        let bottom = document.getElementById('bottom');
        bottom.addEventListener('click', () => {
            if (engine.gravity.y === -0.5) {
                engine.gravity.y = 1; // Set gravity back to default
                bottom.style.backgroundColor = 'red';
            } else {
                engine.gravity.y = -0.5; // Disable gravity
                bottom.style.backgroundColor = 'green';
            }
        });

        function createOverlayObject(id) {
            let overlayObj = document.createElement('div');
            overlayObj.setAttribute('id', id);
            document.getElementById('canv').appendChild(overlayObj);
            return overlayObj;
        }

        var overlayObjects = []
        let overlayBoxA = createOverlayObject('overlay-box-A');
        let overlayBoxB = createOverlayObject('overlay-box-B');

        function updateOverlay() {
            let position = boxA.position;
            let angle = boxA.angle;

            overlayBoxA.style.left = (position.x - 40) + 'px';
            overlayBoxA.style.top = (position.y - 40) + 'px';
            overlayBoxA.style.transform = `rotate(${angle}rad)`;


            if (position.y < 0) {
                Matter.Body.setPosition(boxA, { x: position.x, y: canvasHeight });
            }

            requestAnimationFrame(updateOverlay);
        }

        updateOverlay(); // Call the function to start updating the overlay box


    </script>
</body>

</html>